#+BEGIN_EXPORT html
---
layout: post
title: CppCoreGuidelines P.8 不要泄漏任何资源
categories: [technology]
tags: [CppCoreGuidelines]
---
#+END_EXPORT

- [[http://kimi.im/2021-12-18-cppcoreguidelines-p1][P.1 直接地用代码表达编程设计理念]]
- [[http://kimi.im/2021-12-20-cppcoreguidelines-p2][P.2 用 ISO C++ 标准写代码]]
- [[http://kimi.im/2021-12-20-cppcoreguidelines-p3][P.3 明确地表达程序意图]]
- [[http://kimi.im/2021-12-21-cppcoreguidelines-p4][P.4 理想情况下，程序应该要静态类型安全]]
- [[http://kimi.im/2021-12-22-cppcoreguidelines-p5][P.5 编译时检查比运行时检查好]]
- [[http://kimi.im/2021-12-23-cppcoreguidelines-p6][P.6 不能在编译时检查的，要能在在运行时检查]]
- [[http://kimi.im/2021-12-23-cppcoreguidelines-p7][P.7 尽早捕获运行时错误]]

如果系统是长期运行的，哪怕是很小的资源没有及时释放，都有可能耗尽系统资
源。因此，及时释放系统资源是一种负责任的编程态度。

#+begin_src C++ :results output :exports both :flags -std=c++17 :eval no-export
void f(char* name)
{
    FILE* input = fopen(name, "r");
    // ...
    if (something) return;   // bad: if something == true, a file handle is leaked
    // ...
    fclose(input);
}
#+end_src

以上例程中，如果 ~something~ 为真，函数直接返回了，没有及时关闭 ~input~ 文
件结构体，产生资源泄漏。

#+begin_src C++ :results output :exports both :flags -std=c++17 :eval no-export
void f(char* name)
{
    ifstream input {name};
    // ...
    if (something) return;   // OK: no leak
    // ...
}
#+end_src

改用 ~ifstream~ 文件输入对象可以避免资源泄漏。当函数返回的时候，自动调用
解构函数释放内存数据。

所谓的泄漏（leak）通俗的讲，就是出现任何没有及时释放的资源（anything
that isn't cleaned up）。细分下去，更重要的一类泄漏是：任何不能被释放
的资源（anything that can no longer be cleaned up）。比如在堆中分配一
个对象，然后运行过程中，对象的地址指针被覆盖掉了。于是，就再也没办法释
放这个对象了。所以，对任何中途结束的程序，要么释放内存，要么把分配的对
象返回给上层函数继续使用或者晚些时候释放。

建议：
- 审查指针的使用。区分有主和无主指针。如以上例子用标准库资源句柄替换。
  或者用 GSL 中的 ~unique_ptr~ 和 ~shared_ptr~ 标记指针所有权。
- 审查暴露的 ~new~ 和 ~delete~ ，相对的是封装的 ~new~ ：
  #+begin_src C++
  shared_ptr<int> p(new int[10])
  #+end_src
- 审查返回裸指针（raw pointer）的资源分配函数。比如： ~fopen~, ~malloc~,
  ~strdup~.
