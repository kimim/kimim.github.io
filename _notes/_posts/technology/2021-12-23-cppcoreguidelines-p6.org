#+BEGIN_EXPORT html
---
layout: post
title: CppCoreGuidelines P.6 不能在编译时检查的，要能在在运行时检查
categories: [technology]
tags: [CppCoreGuidelines]
---
#+END_EXPORT

- [[http://kimi.im/2021-12-18-cppcoreguidelines-p1][P.1 直接地用代码表达编程设计理念]]
- [[http://kimi.im/2021-12-20-cppcoreguidelines-p2][P.2 用 ISO C++ 标准写代码]]
- [[http://kimi.im/2021-12-20-cppcoreguidelines-p3][P.3 明确地表达程序意图]]
- [[http://kimi.im/2021-12-21-cppcoreguidelines-p4][P.4 理想情况下，程序应该要静态类型安全]]
- [[http://kimi.im/2021-12-22-cppcoreguidelines-p5][P.5 编译时检查比运行时检查好]]

如果程序里有很难检查到的错误的话，可能会在特定的条件下，导致莫明其妙的
错误。因此要尽量在编译时和运行时检测到这些错误。当然，错误检测是需要代
价的，如计算资源、计算时间。

#+begin_src C++ :results output :exports both :flags -std=c++17 :eval no-export
#include <iostream>
using namespace std;
void f(int* p) {
    cout << p[50];
}

void g(int n)
{
    // bad: the number of elements is not passed to f()
    f(new int[n]);
}
int main()
{
    g(3);
    return 0;
}
#+end_src

#+RESULTS:
: -2043739824

以上代码打印出了一个莫明其妙的数字。因为数组大小没有传给 ~f~ ，在 ~f~ 中又
可以访问 ~p~ 的任意元素。

#+begin_src C++ :results output :exports both :flags -std=c++17 :eval no-export
#include <iostream>
using namespace std;
void f2(int* p, int n) {
    cout << p[n];
}

void g2(int n)
{
    f2(new int[n], 10);  // bad: a wrong number of elements can be passed to f()
}
int main()
{
    g2(3);
    return 0;
}
#+end_src

#+RESULTS:
: 1647575376

上面代码虽然添加了数组大小作为参数，但是这个参数的值可以是任何数字，一
旦数值给错，就访问越界了，所以也不安全。

#+begin_src C++ :results output :exports both :flags -std=c++17 :eval no-export
#include <iostream>
#include <memory>
using namespace std;
void f3(unique_ptr<int[]> p, int n) {
    cout << p[n];
}

void g3(int n)
{
    f3(make_unique<int[]>(n), 10);    // bad: pass ownership and size separately
}
int main()
{
    g3(3);
    return 0;
}
#+end_src

#+RESULTS:
: -1123024560

独占指针（ ~unique_ptr~ ）可以用来传递指针所有权。但是上面还是又单独的传
了个数组大小参数给 ~f3~ 。错误的参数，依然会导致数组越界访问。

#+begin_src C++ :results output :exports both :flags -std=c++17 :eval no-export
#include <iostream>
#include <memory>
#include <vector>
#include <gsl/gsl>
using namespace std;
void f4(vector<int>& v) {
    cout << v[5];
}
void f5(gsl::span<int> v) {
    cout << v[5];
}

void g3(int n)
{
    vector<int> v(n);
    f4(v);                     // pass a reference, retain ownership
    f5(gsl::span<int>{v});          // pass a view, retain ownership
}
int main()
{
    g3(9);
    return 0;
}
#+end_src

#+RESULTS:
: 0

以上代码，通过引用和 ~span~ view 的方式传递参数，数组大小是对象自身包含
的数据，可以在运行时检查访问越界。

以下代码使用 ~vector~ 对象能够传递所有权，并且同时保留了大小信息：

#+begin_src C++ :results output :exports both :flags -std=c++17 :eval no-export
#include <iostream>
#include <vector>
#include <gsl/gsl>
using namespace std;
using namespace gsl;
vector<int> f5(int n)       // OK: move
{
    vector<int> v(n);
    // ... initialize v ...
    return v;
}

unique_ptr<int[]> f6(int n)  // bad: loses n
{
    auto p = make_unique<int[]>(n);
    // ... initialize *p ...
    return p;
}

owner<int*> f7(int n)        // bad: loses n and we might forget to delete
{
    owner<int*> p = new int[n];
    // ... initialize *p ...
    return p;
}

int main()
{
    auto v5 = f5(5);
    cout << v5.size() << endl;
    cout << v5.at(4) << endl;
    auto v6 = f6(5);
    cout << v6[6] << endl;   // out of range
    auto v7 = f7(5);
    cout << v7[6] << endl;   // out of range
    delete v7;
    return 0;
}
#+end_src

#+RESULTS:
: 5
: 0
: -1355022000
: -1554522460
